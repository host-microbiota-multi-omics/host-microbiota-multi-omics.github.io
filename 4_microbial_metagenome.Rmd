# Microbial metagenome {-}

Microbial metagenomic assembly and binning are key steps in reconstructing the genomes of microorganisms present 
in complex communities. This chapter describes the Snakemake rules that perform metagenomic assembly using MEGAHIT, 
create Bowtie2 indices for the assemblies, map reads back to the assemblies, calculate contig coverage, and bin contigs 
into metagenome-assembled genomes (MAGs) using multiple binning tools (MetaBAT2, MaxBin2, SemiBin2). Finally, it covers 
the refinement of bins using Binette to produce high-quality MAGs for downstream analyses.

## Assembly with Megahit

This rule performs metagenomic assembly using MEGAHIT. For each defined assembly group, 
it gathers the metagenomic paired-end reads (R1 and R2) from one or more samples, combines them, 
and runs MEGAHIT to reconstruct longer contiguous sequences (contigs) from the short reads. This can be a 
single-sample assembly or a co-assembly of multiple related samples, depending on how ASSEMBLY_TO_SAMPLES is defined. 
The result is a FASTA file containing assembled contigs that represent fragments of microbial genomes present in the 
samples, filtered to retain only contigs above a certain minimum length to focus on more reliable sequences.

The rule ensures that the output directory is clean before each run, uses multiple threads and dynamically allocated 
memory to handle larger datasets, and then standardizes the output by renaming MEGAHIT's final contig file to a consistent 
path and filename. This assembled contig file becomes the basis for downstream cataloging steps such as binning, annotation, 
and construction of metagenome-assembled genomes (MAGs) in the host-microbiota multi-omics workflow.

```{sh eval=FALSE}
rule assembly:
    input:
        r1=f"{READS}/{{sample}}_1.fq.gz",
        r2=f"{READS}/{{sample}}_2.fq.gz"
    output:
        f"{WORKDIR}/metagenomics/megahit/{{sample}}.fna"
    params:
        outputdir=f"{WORKDIR}/metagenomics/megahit/{{sample}}"
    shell:
        """
        module load megahit/1.2.9
        rm -rf {params.outputdir}

        megahit \
            -t {threads} \
            --verbose \
            --min-contig-len 1500 \
            -1 {input.r1} -2 {input.r2} \
            -o {params.outputdir}
        mv {params.outputdir}/final.contigs.fa {output}
        """
```

## Assembly index

This rule creates a Bowtie2 index for each metagenomic assembly generated in the previous step. 
It takes the assembled contigs (the reconstructed metagenome) and runs bowtie2-build to generate the 
indexing files required for efficient read alignment. Indexing metagenomic assemblies is essential for 
downstream processes such as read recruitment, contig coverage estimation, binning, and quality assessment 
of assembled genomes.

The rule ensures the index is stored alongside the assembly under a consistent naming scheme, allowing later 
rules to easily locate it. It uses modest computational resources, since indexing contigs is generally 
lightweight compared to assembly, and loads the correct Bowtie2 module to guarantee reproducibility. This step 
prepares the assembled contigs to be used as a searchable reference in subsequent cataloging analyses.

```{sh eval=FALSE}
rule assembly_index:
    input:
        f"{WORKDIR}/metagenomics/megahit/{{sample}}.fna"
    output:
        index=f"{WORKDIR}/metagenomics/megahit/{{sample}}.rev.2.bt2"
    params:
        basename=f"{WORKDIR}/metagenomics/megahit/{{sample}}"
    shell:
        """
        module load bowtie2/2.4.2
        bowtie2-build {input} {params.basename}
        """
```

## Assembly mapping

This rule maps each sample's metagenomic reads back to a specific metagenomic assembly using Bowtie2. 
By aligning the cleaned, host-filtered reads to the assembled contigs, the workflow can quantify how much 
support each contig has across samples—information that is essential for downstream steps such as binning, 
abundance estimation, contamination checking, and cross-sample comparative analyses. The rule uses the Bowtie2 
index generated for the assembly and the final FASTQ files produced during host–microbiota read separation.

The alignment output is directly converted to a sorted BAM file through samtools, ensuring the result is 
immediately usable for coverage calculation or other depth-based analyses. With multi-threading support and 
adaptive resource allocation, the rule efficiently handles both small and large datasets. This mapping step 
links reads back to the assembly, turning raw contigs into quantitatively interpretable components of the 
microbial community.

```{sh eval=FALSE}
rule assembly_map:
    input:
        index=f"{WORKDIR}/metagenomics/megahit/{{sample}}.rev.2.bt2",
        r1=f"{READS}/{{sample}}_1.fq.gz",
        r2=f"{READS}/{{sample}}_2.fq.gz"
    output:
        f"{WORKDIR}/metagenomics/bowtie2/{{sample}}.bam"
    params:
        basename=f"{WORKDIR}/metagenomics/megahit/{{sample}}"
    shell:
        """
        module load bowtie2/2.4.2 samtools/1.21
        bowtie2 -x {params.basename} -1 {input.r1} -2 {input.r2} | samtools view -bS - | samtools sort -o {output}
        """
```

## Assembly map depth

This rule computes per-contig read depth across all samples associated with a given assembly. 
It takes the set of BAM files produced by mapping each sample's metagenomic reads back to the assembly 
and uses `jgi_summarize_bam_contig_depths` (from MetaBAT2) to generate a depth table. This table reports 
how many reads align to each contig in each sample—information that is essential for binning tools, which 
rely on differential coverage patterns to group contigs into metagenome-assembled genomes (MAGs).

The rule outputs two versions of the depth file: the full MetaBAT2-compatible depth matrix and a simplified 
depth file formatted for MaxBin2. These coverage profiles are a key input for downstream binning workflows, 
as they allow algorithms to distinguish which contigs likely originate from the same genome.

```{sh eval=FALSE}
rule assembly_map_depth:
    input:
        f"{WORKDIR}/metagenomics/bowtie2/{{sample}}.bam"
    output:
        metabat2=f"{WORKDIR}/metagenomics/bowtie2/{{sample}}_metabat.depth",
        maxbin2=f"{WORKDIR}/metagenomics/bowtie2/{{sample}}_maxbin.depth"
    shell:
        """
        module load metabat2/2.17
        jgi_summarize_bam_contig_depths --outputDepth {output.metabat2} {input}
        cut -f1,3 {output.metabat2} | tail -n+2 > {output.maxbin2}
        """
```

### Binning with MetaBat2

MetaBAT2 clusters contigs based mainly on differential coverage across samples and tetranucleotide frequency, 
producing a TSV mapping contigs to bins. It is fast, widely used, and effective when multiple samples provide 
rich coverage variation.

```{sh eval=FALSE}
rule metabat2:
    input:
        assembly=f"{WORKDIR}/metagenomics/megahit/{{sample}}.fna",
        depth=f"{WORKDIR}/metagenomics/bowtie2/{{sample}}_metabat.depth"
    output:
        f"{WORKDIR}/metagenomics/metabat2/{{sample}}.tsv"
    params:
        basename=f"{WORKDIR}/metagenomics/metabat2/{{sample}}/{{sample}}"
    shell:
        """
        module load metabat2/2.17
        metabat2 -i {input.assembly} -a {input.depth} -o {params.basename} -m 1500 --saveCls

        # Generate summary file for dRep
        find "$(dirname {params.basename})" -maxdepth 1 -type f -name "*$(basename {params.basename})_*.fa" | sort > {output}
        """
```

### Bin quality with CheckM

CheckM2 estimates each bin's completeness and contamination by comparing marker genes against curated
reference profiles. This step provides an objective measure of MAG quality before downstream analyses.
The rule below takes the MetaBAT2 bins for each assembly, runs CheckM2, and writes both a detailed
`quality_report.tsv` and a simplified CSV with just genome name, completeness, and contamination. That
CSV is formatted so dRep can quickly apply quality filters during dereplication.

```{sh eval=FALSE}
rule metabat2:
    input:
        f"{WORKDIR}/metagenomics/metabat2/{{sample}}.tsv"
    output:
        f"{WORKDIR}/metagenomics/checkm2/{{sample}}.tsv"
    params:
        bins_dir=lambda wildcards: f"{WORKDIR}/metagenomics/metabat2/{wildcards.sample}",
        outdir=f"{WORKDIR}/metagenomics/checkm2/{{sample}}"
    shell:
        """
        module load checkm2/1.0.2
        rm -rf {params.outdir}
        mkdir -p {params.outdir}
        checkm2 predict -i {params.bins_dir}/*.fa -o {params.outdir} -t {threads} --database_path /maps/datasets/globe_databases/checkm2/20250215/CheckM2_database/uniref100.KO.1.dmnd

        # Prepare genome info for drep
        awk -F'\t' 'BEGIN{{OFS=","}} NR==1{{print "genome","completeness","contamination"; next}} {{print $1".fna",$2,$3}}' {params.outdir}/quality_report.tsv > {output}
        """
```

### Bin dereplication with dRep

dRep clusters near-identical MAGs and retains the highest-quality representative from each cluster,
reducing redundancy before annotation or comparative genomics. Using the completeness and contamination
estimates from CheckM2, it filters low-quality bins, computes pairwise ANI with FastANI/Mash, and outputs
the selected genomes plus summary tables. The rule consumes the MetaBAT2 bin list and the CheckM2 quality
table, then writes dereplication outputs to a dedicated directory for each assembly.

```{sh eval=FALSE}
rule metabat2:
    input:
        genomes=f"{WORKDIR}/metagenomics/metabat2/{{sample}}.tsv",
        genomeinfo=f"{WORKDIR}/metagenomics/checkm2/{{sample}}.tsv"
    output:
        f"{WORKDIR}/metagenomics/drep/{{sample}}/data_tables/genomeInformation.csv"
    params:
        bins_dir=lambda wildcards: f"{WORKDIR}/metagenomics/metabat2/{wildcards.sample}",
        outdir=f"{WORKDIR}/metagenomics/drep/{{sample}}"
    shell:
        """
        module load drep/3.6.2 fastani/1.33 mash/2.3
        rm -rf {params.outdir}
        dRep dereplicate {params.outdir} -g {input.genomes} -p {threads} -pa 0.95 --genomeInfo {input.genomeinfo}
        """
```

## Taxonomic annotation with GTDB-tk

GTDB-Tk classifies each dereplicated MAG against the curated Genome Taxonomy Database, providing standardized
domain-to-species labels and quality-controlled marker gene checks. Adding taxonomy here anchors downstream
interpretations—linking functional profiles, differential abundance, or host associations to known clades and
flagging potential contaminants or mis-binned genomes. The rule will take the dereplicated bins, run GTDB-Tk,
and emit per-genome classifications plus summary reports for quick review.

```{sh eval=FALSE}
rule gtdbtk:
    output:
        f"{WORKDIR}/metagenomics/gtdbtk/classify/gtdbtk.bac120.summary.tsv"
    params:
        bindir=BINDIR,
        outdir=f"{WORKDIR}/metagenomics/gtdbtk"
    shell:
        """
        export GTDBTK_DATA_PATH=/datasets/globe_databases/gtdbtk_db/20241001
        gtdbtk classify_wf \
            --genome_dir {params.bindir} \
            --out_dir {params.outdir} \
            --cpus {threads} \
            --extension fa \
            --skip_ani_screen
```

## Gene prediction with Prodigal

This rule predicts genes in dereplicated MAGs using Prodigal, generating GFF annotations, nucleotide sequences, and amino acid sequences. 
Gene prediction is a crucial step for functional annotation, as it identifies coding regions within the MAGs that can be further analyzed for their potential roles in microbial metabolism and ecology.

```{sh eval=FALSE}
rule prodigal:
    input:
        f"{BINDIR}/{{mag}}.fa"
    output:
        gff=f"{WORKDIR}/metagenomics/prodigal/{{mag}}.gff",
        nt=f"{WORKDIR}/metagenomics/prodigal/{{mag}}.fna",
        aa=f"{WORKDIR}/metagenomics/prodigal/{{mag}}.faa"
    shell:
        """module 
        mkdir -p $(dirname {output.gff})
        module load pprodigal/1.0.1
        prodigal -i {input} -o {output.gff} -d {output.nt} -a {output.aa} -p single
        """
```


## Functional annotation with KEGG hmms

This rule annotates dereplicated MAGs using KEGG HMM profiles to assign functional roles based on gene content.  
It takes the predicted amino acid sequences from Prodigal and scans them against the KEGG Orthology HMM database using HMMER's hmmscan. 
The output includes both a detailed text file and a tab-separated values (TSV) file summarizing the functional annotations for each gene. 
This functional annotation step is essential for understanding the metabolic capabilities of the reconstructed genomes and their potential roles 
within microbial communities.

```{sh eval=FALSE}
rule kegg:
    input:
        f"{WORKDIR}/metagenomics/prodigal/{{mag}}.faa"
    output:
        txt=f"{WORKDIR}/metagenomics/kegg/{{mag}}.txt",
        tsv=f"{WORKDIR}/metagenomics/kegg/{{mag}}.tsv"
    params:
        db="/projects/alberdilab/data/databases/drakkar/kofams"
    shell:
        """
        module load hmmer/3.3.2
        hmmscan -o {output.txt} --tblout {output.tsv} -E 1e-10 --noali {params.db} {input}
        """
```
